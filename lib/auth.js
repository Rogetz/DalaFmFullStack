// custom package.
const mongoose = require("mongoose")
require("dotenv").config({path: "D:/PublishWebApps/DalaFm/fullStack/.env"})

mongoose.connect(process.env.MONGODB_NEW_CONNECTION)
const path = require("path")

// third party packages
const bcrypt = require("bcrypt")
// using a path here since in development mode I placed this Api in another directory.
const jwt = require("jsonwebtoken")


//The user schema and model
//userName can never be the same so use it as a key

// I forgot to store the various salts for the users password and so testing them has been quite difficult 

// lesson learnt in functions,have only one nested function in each function, never have more than one,so that you can get the return types for asynchronous functions
// once you've used asynchronous functions always use it to the top most function, await and async  to the top

let userSchema = new mongoose.Schema({
    fullName: String,
    userName: String,
    email: String,
    password: String,
    salt: String // an Id is turned to a string, so It really doesnt matter, though I'd use an Id is its the identification mechanism
})


let userModel = mongoose.model("authData",userSchema)

// login functionality
exports.logIn = async function logIn(userReceived,fn){
    let user = userReceived

    let {err,userFound} = await collectionSearcher(user,function(error,usersFound){
        /*if(error != null){
            fn(error,null)
            
        }
        else{
            //used a callback here to ensure that the usermodel was well assigned.    
            // finally worked I had to pass the user.password directly to the callback for it to be set.
            // One thing am realizing is that the properties set by another method of a class are not directly inherited by the other methods so simply pass the results over to the final method for it to set them itself. mostly this issue is caused by the asynchronous nature of javascript
        }*/
    })
    console.log(`err found: ${err} and document found: ${userFound}`)
    if(err != null){
        //for error
        console.log(`error found in login${err}`)
        return {err:err,documentFound:userFound}
    }
    else{
        // I have returned the function in this way so that it may return whatever result is obtained from here as the final result.
        return loginHashpassword(user,userFound).then(function(hash){
            if(hash ==  userFound.password){
                console.log("password match detected")
                // throw no error so that the method accepts the login
                err = null
                // This is where the jwt is generated by being signed.
                let token = jwt.sign(user,process.env.JWT_SECRET_KEY)
                let userName = user.userName
                let tokenAndUser = `${token},${userName}`
                return {err: err,documentFound: tokenAndUser}
            }
            else{
                err = "invalid password"
                console.log(`error at the login function, ${err}`)
                return {err: err,documentFound: null}                
            }
        }).catch(function(error){
            console.log(error)
            err = "internal server error"
            console.log(err)
            return {err: err,documentFound: null}   
        })
    }
}

// note that this is an example of how its called outside inside it would have been called with the real method.
// returns a user
/*logIn({userName : "Paul",password: "taulo#4321"},function(err,user){
    if(err){
        fn(err,null)
    }
    else{
        fn(null,user)
    }
})*/


// signup functionality
// returns a user logged in already, to avoid the hustle of loggin in again.
// remember that this signup is called after the user has been OTP verified, that functionality will be incorporated by the APIs
exports.signUp = async function signUp(userReceived,fn){
    let user = userReceived


    // The problem here was deep nesting of asynchronous functions and its what brought up the errors
    // Thats why am campaignig for no more than one nesting, 
    // the hash password function here was the nested function
    let {err,documentFound} = await duplicateTest(user,async function(error,message){
        if(error){
            // logic here useless for our process in  this case. since we want something returned.
            fn(error,null)
        }
        else{
            // logic here is only useful for console but useless for process in thie case            
        }
    })
    if(err == "successful signup"){
        return {err: null,documentFound: documentFound}       
    }
    else if(err){
        return {err:err,result:documentFound}
    }
    else{
        return {err: null,documentFound: "user signed up"}
    }
}


// forgot password functionality
// takes an object uses the username property
// forgot password called after the OTP has been well verified
// The work of this is just to change the OTP and nothing more, its success message is what react uses to display the login view, for the user to login with the new credentials
exports.forgotPassword = async function forgotPassword(user,fn){
    // should return an array,however check on the first index alone.
    let {err,userFound} = await collectionSearcher(user,async function(err,user){
        if(err){
            console.log(`err found at the collection searcher ${err}`)
        }
        else{
            // change the user password
            let salt = await bcrypt.genSalt(12)
            bcrypt.hash(user.password,salt,async function(error,hash){
                if(error){
                    console.log("corrupted credentials")
                }
                else{
                    user.password = hash
                    // I want to filter the exact match of the userName, this will contain unique usernames for everyone remember.
                    let confirmationObject = await userModel.updateOne({userName: user.userName},{$set : {password : hash,salt:salt}})
                    // check the mongoose functionality for updating a field
                    console.log(confirmationObject)
                    // ensure you stick to the order. and not call an error when its actually not an error.
                    // await userModel.insertOne({userName: user.userName,fullName:user.fullName,email: user.email,password: user.password})
                    // Note that for mongoose model has only an insertMany and no insertOne
                }
            })
        }
    })
    if(err){
        return {err:err,documentFound: null}
    }
    else{
        return {err:null,documentFound:userFound}
    }
}

// how its meant to be called.
// the password passed here is the new password remember.
/*forgotPassword({email: "paul@gmail.com",password: "test4#435"},function(err,confirmationObject){
    if(err){
        // send the error to whatever API
    }
    else{
        // send A success response to whatever API. NOT THE confirmation object remember
    }
})*/


// this is a simple searcher for me not for the API I'll not export it.
userModelSearcher =  async function modelSearcher(username,fn){
    let documentsReturned = await userModel.find({userName : username})
    fn(documentsReturned)    
}

// call it in that save method remember it returns an approval message
async function duplicateTest(userReceived,fn){
    let user =  userReceived
    
    let {err,userFound} = await collectionSearcher(user,function(error,collectionDocument){
        /*if(error){
            fn(error,null)
        }
        else{
            if(collectionDocument == null || collectionDocument == "no user found"){
                let approvalMessage = "safe"
                fn(null,approvalMessage)
            }
            else{
                let error = "name duplicated"
                fn(error,null)
            }
        }*/
    })
    // since for a signup this is not an error dont throw an error
    if(err == "no user found"){
        let salt = await bcrypt.genSalt(12)
        user.salt = salt
        console.log(user.salt)
        bcrypt.hash(user.password,salt,async function(error,hash){
            if(error){
                fn("corrupted credentials",null)
            }
            else{
                user.password = hash
                // ensure you stick to the order. and not call an error when its actually not an error.
                // await userModel.insertOne({userName: user.userName,fullName:user.fullName,email: user.email,password: user.password})
                // Note that for mongoose model has only an insertMany and no insertOne
                await userModel.insertMany([{userName: user.userName,fullName:user.fullName,email: user.email,password: user.password,salt: salt}]) 
                // create an object for acknowledging a successful insertion in order to confirm a sucessful signup
                fn(null,user)              
            }
        })
        return {err: "successful signup",documentFound:userFound}
    }
    else if(userFound != null){
        return {err:"name duplicated",documentFound:null}
    }
    else{
        return {err:err,documentFound: userFound}    
    }

}

// I want to update this collection searcher to return only one document each time since it will be using a username for the search, which is unique to every user.
// I'm an advanced developer so here I just had to make the function return an array for the sake of destructuring
// as well as pass some values to the callback function.
async function collectionSearcher(userReceived,fn){
    let user = userReceived

    let documentFound = await userModel.findOne({userName : user.userName})
    console.log(`document found at collection searcher: ${JSON.stringify(documentFound)}`)
    if(documentFound != null){
        fn(null,documentFound)
        //make them objects since arrays can't containt different types
        return {err:null,userFound:documentFound}
    }
    else{
        let err = "no user found"
        console.log(`at the collection searcher: ${err}`)
        // meaning theres no user found and so its safe to store the user.
        fn(err,null)
        return {err:err,userFound:null}
    }
}


//calling the signup test
/*signUp({userName :"paul",password:"test1"},function(err,user){
    if(err == "name duplicated"){
        //send that back to the login client
    }
    if(err){
        // problem with the server try again later
    }
    else{
        // send a user object
    }
})*/

// for testing the login password credentials
async function loginHashpassword(userReceived,userRetrieved){
    let user = userReceived
    let salt = userRetrieved.salt
    console.log(`salt found here is: ${salt}`)
    return new Promise(async function(resolve,reject){
        await bcrypt.hash(user.password,salt,function(error,hash){
            if(error){
                reject("corrupted credentials")
            }
            else{
                resolve(hash)
            }
        })
    })
}


// returns an email.
exports.emailFinder =async function(userName){
    //finding the user
    let userFound = await userModel.findOne({userName : userName})   
    // resolve the userName.
    return new Promise(function(resolve,reject){
        if(userFound != null){
            console.log(userFound)
            let email = userFound.email
            resolve({object:email})
        }
        else{
            resolve({err: "no user found"})
        }
    })

}